<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Tree Derivations</title>

		<meta name="description" content="Tree Derivations: A tour of Haskell by way of diagrams">
		<meta name="author" content="Bob Grudem">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<!-- <link rel="stylesheet" href="css/theme/default.css" id="theme"> -->
		<link rel="stylesheet" href="css/theme/serif.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>Tree Derivations</h2>
					<h4>A tour of Haskell by way of drawing trees</h4>
					<h5>Bob Grudem</h5>
					<p>
						<small><a href="http://github.com/bobgru/tree-derivations">github.com/bobgru/tree-derivations</a></small>
					</p>
				</section>

				<section>
					<h3>The Trees</h3>
					<p>
						Starting from a short program to draw a stick figure...
					</p>
					<img src="images/stick-figure.svg">
					<aside class="notes">
					</aside>
				</section>

				<section>
					<h3>The Trees</h3>
					<p>
						...we will add tapered branches...
					</p>
					<img src="images/tapered.svg">
					<aside class="notes">
					</aside>
				</section>
				
				<section>
					<h3>The Trees</h3>
					<p>
						...and finally draw a tree modeled in 3D
					</p>
					<img src="images/deep-3d-2.svg">
					<aside class="notes">
					</aside>
				</section>
				
				<section>
					<h3>Stick Figure—The Code</h3>
					<pre><code data-trim>
module Main where
import Data.Tree(flatten, unfoldTree)
import Diagrams.Backend.SVG.CmdLine(defaultMain)
import Diagrams.Prelude

main       = defaultMain $ pad 1.1 $ renderTree buildTree
renderTree = mconcat . flatten . fmap drawBranch
buildTree  = unfoldTree branches seed
seed       = (origin, unitY)
drawBranch (p, v) = position [(p, fromOffsets [v])]
branches   (p, v)
    | magnitude v < 0.05  =  ((p, v), [])
    | otherwise           =  ((p, v), pvs)
    where pvs  = [(p', br (1/7)), (p', br (-1/7))]
          p'   = p .+^ v
          br a = v # scale 0.6 # rotateBy a
					</code></pre>
					<p>
						<small><a href="http://github.com/bobgru/tree-derivations/src/StickFigure0.hs">src/StickFigure0.hs</a></small>
					</p>
				</section>

				<section>
					<h3>Stick Figure—What of Haskell?</h3>
					<ul>
						<li>The module system, Hackage, the Haskell Platform</li>
						<li>Function definition and application ($), the IO monad</li>
						<li>Point-free composition, higher-order functions</li>
						<li>Partial application, currying, functors</li>
						<li>Tuples, pattern matching, lists</li>
						<li>Guards, the where clause, apostrophe in names</li>
						<li>Custom operators—(.+^) from Data.AffineSpace</li>
						<li>Nested functions, post-application (#)</li>
						<li>Type inference, type class instances, lazy evaluation</li>
					</ul>
				</section>

				<section>
					<h3>Stick Figure—What Not?</h3>
					<ul>
						<li>Data structures</li>
						<li>Type declarations</li>
						<li>Explicit recursion</li>
						<li>Infinite data structures</li>
						<li>Sequence, loops, and conditionals (!)</li>
						<li>Comments and whitespace (not much)</li>
					</ul>
				</section>

				<section>
					<h3>Stick Figure—Further<br>Casual Analysis</h3>
					<ul>
						<li>Declarative specification</li>
						<li>Dense code—6 functions, 5 one-liners</li>
						<li>Almost-infinite tree (?)</li>
						<li>Control flow structures as code</li>
						<li>Layout mostly to suit taste</li>
						<li>Type inference as convenience</li>
					</ul>
				</section>
				
				<section>
					<section>
					<h3>Stick Figure—Preparing for Tapered</h3>
					<p>Refactor the code (no change to behavior!)</p>
					<ol>
						<li>Add module name and type declarations</li>
						<li>Extract constants into configuration data structure</li>
						<li>Extract calculation of branch tips into new function</li>
						<li>Add explicit width</li>
						<li>Add white space and reformat slightly</li>
					</ol>
					</section>

					<section>
						<h3>Stick Figure—Preparing for Tapered</h3>
						<p>Add module name and type declarations</p>
						<pre><code data-trim>
module Main where
import Data.Tree(Tree, flatten, unfoldTree)
import Diagrams.Backend.SVG.CmdLine(defaultMain)
import Diagrams.Backend.SVG(SVG)
import Diagrams.Prelude

type TreeNode = (P2, R2)
type Dgm = Diagram SVG R2
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/StickFigure3.hs">src/StickFigure3.hs</a></small>
						</p>
					</section>

					<section>
						<h3>Stick Figure—Preparing for Tapered</h3>
						<p>Define configuration data structure</p>
						<pre><code data-trim>
data TreeConfig = TC {
    tcScale        :: Double,
    tcCutOff       :: Double,
    tcMinWidth     :: Double,
    tcInitialWidth :: Double,
    tcBranchScale  :: Double,
    tcBranchAngle  :: Double
} deriving (Show)
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/StickFigure3.hs">src/StickFigure3.hs</a></small>
						</p>
					</section>

					<section>
						<h3>Stick Figure—Preparing for Tapered</h3>
						<p>Extract constants into configuration data structure</p>
						<pre><code data-trim>
tc :: TreeConfig
tc = TC {
    tcScale        = s,
    tcCutOff       = 0.05 * s,
    tcMinWidth     = 0.01 * s,
    tcInitialWidth = 0.01 * s,
    tcBranchScale  = 0.6,
    tcBranchAngle  = 1/7
}
    where s = 10000
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/StickFigure3.hs">src/StickFigure3.hs</a></small>
						</p>
					</section>

					<section>
						<h3>Stick Figure—Preparing for Tapered</h3>
						<p>Extract calculation of branch tips into new function</p>
						<pre><code data-trim>
branches :: TreeNode -> (TreeNode, [TreeNode])
branches n@(_, v)
    | magnitude v < tcCutOff tc  =  (n, [])
    | otherwise                  =  (n, branchTips n)

branchTips :: TreeNode -> [TreeNode]
branchTips (p, v) = [(p', br a), (p', br (-a))]
    where p'   = p .+^ v
          br a = v # scale (tcBranchScale tc) # rotateBy a
          a    = tcBranchAngle tc
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/StickFigure3.hs">src/StickFigure3.hs</a></small>
						</p>
					</section>

					<section>
						<h3>Stick Figure—Preparing for Tapered</h3>
						<p>Add explicit width</p>
						<pre><code data-trim>
type TreeNode = (P2, R2, Double)
						</code></pre>
						<pre><code data-trim>
tcInitialWidth :: Double,
						</code></pre>
						<pre><code data-trim>
tcInitialWidth = 0.01 * s,
						</code></pre>
						<pre><code data-trim>
seed = (origin, unitY ^* tcScale tc, tcInitialWidth tc)
drawBranch (p, v, w) = position [(p, fromOffsets [v])] # lw w
	...
branches n@(_, v, _)
	...
branchTips (p, v, w) = [(p', br a, w), (p', br (-a), w)]
	...
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/StickFigure3.hs">src/StickFigure3.hs</a></small>
						</p>
					</section>
				</section>

				<section>
					<section>
						<h3>Tapered Branches—The Code</h3>
						<ol>
							<li>Increase the initial width and add taper</li>
							<li>If minimum width, draw line; otherwise, draw trapezoid.</li>
							<li>Apply the taper, enforcing a minimum width</li>
						</ol>
					</section>
					<section>
						<h3>Tapered Branches—The Code</h3>
						<p>Increase the initial width and add taper</p>
						<pre><code data-trim>
tcWidthTaper   :: Double,
						</code></pre>
						<pre><code data-trim>
tcInitialWidth = 0.1  * s,
tcWidthTaper   = 0.7,
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/Tapered0.hs">src/Tapered0.hs</a></small>
						</p>
					</section>
				
					<section>
						<h3>Tapered Branches—The Code</h3>
						<p>If minimum width, draw line; otherwise, draw trapezoid.</p>
						<pre><code data-trim>
drawBranch n@(p, v, w) = place d p
    where d | w <= tcMinWidth tc  =  lineSegment v w
            | otherwise           =  trapezoid n
lineSegment v w     = fromOffsets [v] # lw w
trapezoid (p, v, w) = (closeLine . lineFromVertices) [ p, a, b, c, d ]
                    # strokeLoop # fc black # lw 0.01
    where p' = p .+^ v
          w' = taperWidth w
          n  = v # rotateBy (1/4) # normalized
          w2 = w  / 2 ; w2' = w' / 2
          a  = p  .-^ (w2  *^ n) ; b = p' .-^ (w2' *^ n)
          c  = p' .+^ (w2' *^ n) ; d = p  .+^ (w2  *^ n)
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/Tapered0.hs">src/Tapered0.hs</a></small>
						</p>
					</section>

					<section>
						<h3>Tapered Branches—The Code</h3>
						<p>Apply the taper, enforcing a minimum width</p>
						<pre><code data-trim>
taperWidth :: Double -> Double
taperWidth w = max (w * tcWidthTaper tc) (tcMinWidth tc)
						</code></pre>
						<pre><code data-trim>
branchTips (p, v, w) = [(p', br a, w'), (p', br (-a), w')]
          ...
          w'   = taperWidth w
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/Tapered0.hs">src/Tapered0.hs</a></small>
						</p>
					</section>
				</section>

				<section>
					<section>
						<h3>Tapered Branches—Preparing for 3D</h3>
						<p>Refactor the code (no change to behavior!)</p>
						<ol>
							<li>Import 3D libraries</li>
							<li>Change seed to unitZ from unitY</li>
							<li>Add functions to project point and branch node</li>
							<li>Apply rotation in 3D instead of 2D</li>
							<li>Update comments to reflect new types</li>
						</ol>
					</section>
					
					<section>
						<h3>Tapered Branches—Preparing for 3D</h3>
						<p>Import 3D libraries and change seed to unitZ</p>
						<pre><code data-trim>
import Diagrams.ThreeD.Transform(aboutY)
import Diagrams.ThreeD.Types(unp3)
import Diagrams.ThreeD.Vector(unitZ)
						</code></pre>
						<pre><code data-trim>
seed = (origin, unitZ ^* tcScale tc, tcInitialWidth tc)
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/Tapered1.hs">src/Tapered1.hs</a></small>
						</p>
					</section>

					<section>
						<h3>Tapered Branches—Preparing for 3D</h3>
						<p>Add functions to project point and branch node</p>
						<pre><code data-trim>
renderTree = mconcat . flatten . fmap drawBranch . fmap projectNode
						</code></pre>
						<pre><code data-trim>
--projectNode :: TreeNode3 -> TreeNode
projectNode (p, v, w) = (p', v', w)
    where q  = p .+^ v
          q' = projectPtXZ q
          p' = projectPtXZ p
          v' = q' .-. p'

--projectPtXZ :: P3 -> P2
projectPtXZ p = case unp3 p of (x, _, z) -> p2 (x, z)
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/Tapered1.hs">src/Tapered1.hs</a></small>
						</p>
					</section>

					<section>
						<h3>Tapered Branches—Preparing for 3D</h3>
						<p>Apply rotation in 3D instead of 2D</p>
						<pre><code data-trim>
br a = v # scale (tcBranchScale tc) # t a
...
t a  = transform (aboutY (a @@ turn))
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/Tapered1.hs">src/Tapered1.hs</a></small>
						</p>
					</section>

					<section>
						<h3>Tapered Branches—Preparing for 3D</h3>
						<p>Update comments to reflect new types</p>
						<pre><code data-trim>
--type TreeNode3 = (P3, R3, Double)
--renderTree :: Tree TreeNode3 -> Dgm
--buildTree  :: Tree TreeNode3
--seed       :: TreeNode3
--branches   :: TreeNode3 -> (TreeNode3, [TreeNode3])
--branchTips :: TreeNode3 -> [TreeNode3]
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/Tapered1.hs">src/Tapered1.hs</a></small>
						</p>
					</section>
				</section>

				<section>
					<section>
						<h3>Deep 3D—The Code</h3>
						<ol>
							<li>Import needed library functions</li>
							<li>Tune cut off length</li>
							<li>Rewrite branchTips</li>
							<li>Add inject and mkTip functions</li>
							<li>Add pointAt'' function</li>
						</ol>
					</section>

					<section>
						<h3>Deep 3D—The Code</h3>
						<p>Import needed library functions and tune cut off</p>
						<pre><code data-trim>
import Data.Cross(cross3)
...
import Diagrams.Prelude hiding (rotationAbout, direction, angleBetween)
import Diagrams.ThreeD.Transform(aboutY, pointAt', rotationAbout)
import Diagrams.ThreeD.Types(unp3, R3, r3, T3, Spherical)
import Diagrams.ThreeD.Vector(unitZ, direction, angleBetween)
						</code></pre>
						<pre><code data-trim>
tcCutOff       = 0.12 * s,
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/Deep3D.hs">src/Deep3D.hs</a></small>
						</p>
					</section>

					<section>
						<h3>Deep 3D—The Code</h3>
						<p>Rewrite branchTips</p>
						<pre><code data-trim>
-- Build a regular polygon in the XY-plane and tilt it perpendicular
-- to the vector it branches from. Orient the polygon to make the
-- projection more interesting.
--branchTips :: TreeNode3 -> [TreeNode3]
branchTips n@(_, v, _) = polygon po
                       # map (.-. origin)
                       # map inject
                       # map (^+^ (unitZ ^* h))
                       # map (transform (pointAt'' unitZ unitZ v))
                       # map (^*  (magnitude v * tcBranchScale tc))
                       # map (mkTip n)
    where po = PolygonOpts (PolyRegular c s) (OrientTo v') origin
          c  = 3            -- number of sides
          s  = 0.782        -- length of side
          v' = r2 (1,3)     -- orientation vector
          h  = 0.623        -- "height" of tips above base
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/Deep3D.hs">src/Deep3D.hs</a></small>
						</p>
					</section>

					<section>
						<h3>Deep 3D—The Code</h3>
						<p>Add inject and mkTip functions</p>
						<pre><code data-trim>
--inject :: R2 -> R3
inject v = case unr2 v of (x, y) -> r3 (x, y, 0)
						</code></pre>
						<pre><code data-trim>
--mkTip :: TreeNode3 -> R3 -> TreeNode3
mkTip (p, v, w) v' = (p .+^ v, v', taperWidth w)
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/Deep3D.hs">src/Deep3D.hs</a></small>
						</p>
					</section>

					<section>
						<h3>Deep 3D—The Code</h3>
						<p>Add pointAt'' function</p>
						<pre><code data-trim>
-- Copied from http://projects.haskell.org/diagrams/haddock/src/
-- Diagrams-ThreeD-Transform.html#pointAt
-- and modified to change the calculation of tilt angle.
-- Also eliminating panning, which is done for us automatically
-- by virtue of the relative vector spaces of composed subdiagrams.
-- There is already a function called pointAt'.
--pointAt'' :: R3 -> R3 -> R3 -> T3
pointAt'' about initial final = tilt
    where
        tiltAngle = angleBetween initial final
        tiltDir   = direction $ cross3 about final :: Spherical
        tilt      = rotationAbout origin tiltDir tiltAngle
						</code></pre>
						<p>
							<small><a href="http://github.com/bobgru/tree-derivations/src/Deep3D.hs">src/Deep3D.hs</a></small>
						</p>
					</section>
				</section>

				<section>
					<section>
						<h3>A Note on Type Inference</h3>
						<p>According to my hint (Tapered0.hs)</p>
						<pre><code data-trim>
--branchTips :: TreeNode -> [TreeNode]
						</code></pre>
						<p>According to my hint (Deep3D.hs)</p>
						<pre><code data-trim>
--branchTips :: TreeNode3 -> [TreeNode3]
						</code></pre>
					</section>

					<section>
						<h3>A Note on Type Inference</h3>
						<p>According to GHCI (cabal repl tapered-0)</p>
						<pre><code data-trim>
tree-derivations$ cabal repl tapered-0
...
Ok, modules loaded: Main.
λ: :t branchTips 
branchTips
  :: (vector-space-0.8.6:Data.AffineSpace.AffineSpace t,
      diagrams-core-1.1.0.3:Diagrams.Core.Transform.Transformable
        (vector-space-0.8.6:Data.AffineSpace.Diff t),
      diagrams-core-1.1.0.3:Diagrams.Core.V.V
        (vector-space-0.8.6:Data.AffineSpace.Diff t)
      ~ Diagrams.TwoD.Types.R2) =>
     (t, vector-space-0.8.6:Data.AffineSpace.Diff t, Double)
     -> [(t, vector-space-0.8.6:Data.AffineSpace.Diff t, Double)]
						</code></pre>
					</section>

					<section>
						<h3>A Note on Type Inference</h3>
						<p>According to GHCI (cabal repl deep-3d)</p>
						<pre><code data-trim>
tree-derivations$ cabal repl deep-3d
...
Ok, modules loaded: Main.
λ: :t branchTips 
branchTips
  :: (Data.AffineSpace.AffineSpace t,
      Data.AffineSpace.Diff t ~ Diagrams.ThreeD.Types.R3) =>
     (t, Diagrams.ThreeD.Types.R3, Double)
     -> [(t, Diagrams.ThreeD.Types.R3, Double)]
						</code></pre>

					</section>
				</section>

				<!-- <section id="themes">
					<h2>Themes</h2>
					<p>
						Reveal.js comes with a few themes built in: <br>
						<a href="?#/themes">Default</a> -
						<a href="?theme=sky#/themes">Sky</a> -
						<a href="?theme=beige#/themes">Beige</a> -
						<a href="?theme=simple#/themes">Simple</a> -
						<a href="?theme=serif#/themes">Serif</a> -
						<a href="?theme=night#/themes">Night</a> <br>
						<a href="?theme=moon#/themes">Moon</a> -
						<a href="?theme=solarized#/themes">Solarized</a>
					</p>
					<p>
						<small>
							* Theme demos are loaded after the presentation which leads to flicker. In production you should load your theme in the <code>&lt;head&gt;</code> using a <code>&lt;link&gt;</code>.
						</small>
					</p>
				</section> -->

				<section>
					<h3>Resources</h3>
					<small>
					<table>
						<tr>
							<td style="text-align:right">Tree-derivations</td>
							<td></td>
							<td><a href="http://github.com/bobgru/tree-derivations">http://github.com/bobgru/tree-derivations</a></td>
						</tr>
						<tr>
							<td style="text-align:right">The Haskell Platform</td>
							<td></td>
							<td><a href="http://www.haskell.org/platform">http://www.haskell.org/platform</a></td>
						</tr>
						<tr>
							<td style="text-align:right">Diagrams</td>
							<td></td>
							<td><a href="http://projects.haskell.org/diagrams">http://projects.haskell.org/diagrams</a></td>
						</tr>
						<tr>
							<td style="text-align:right">Standard containers</td>
							<td></td>
							<td><a href="http://hackage.haskell.org/package/containers-0.5.5.1">http://hackage.haskell.org/package/containers-0.5.5.1</a></td>
						</tr>
						<tr>
							<td style="text-align:right">reveal.js</td>
							<td></td>
							<td><a href="http://lab.hakim.se/reveal-js">http://lab.hakim.se/reveal-js</a></td>
						</tr>
						<tr>
							<td style="text-align:right">L-Systems</td>
							<td></td>
							<td><a hsrc="http://algorithmicbotany.org/papers/abop/abop-ch1.pdf">http://algorithmicbotany.org/papers/abop/abop-ch1.pdf</a></td>
						</tr>
						<tr>
							<td style="text-align:right">Git</td>
							<td></td>
							<td><a href="http://git-scm.com">http://git-scm.com</a></td>
						</tr>
					</table>
					</small>
				</section>

				<section>
					<h3>The End</h3>
					<img src="images/stick-figure.svg" width=300>
					<img src="images/tapered.svg" width=300>
					<img src="images/deep-3d-2.svg" width=268>
					<p>
						<small><a href="http://github.com/bobgru/tree-derivations">github.com/bobgru/tree-derivations</a></small>
					</p>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
